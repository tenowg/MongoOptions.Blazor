@using System.Reflection
@using Microsoft.AspNetCore.Components.Forms
@using MongoOptions.Blazor.Fragments
@using MongoOptions.Extensions
@using MongoOptions.Interfaces
@using MongoOptions.Types
@typeparam TKey where TKey : notnull
@typeparam TValue

<div class="mb-dictionary-editor">
    @foreach (var key in Items.Keys.ToList())
    {
        <div class="mb-dictionary-item">
            <div class="col mb-dictionary-key">
                <input class="form-control form-control-sm" value="@key" @onchange="@(e => UpdateKey(key, e.Value!))" />
            </div>
            <div class="col">
                @if (typeof(TValue).IsPrimitive || typeof(TValue) == typeof(string))
                {
                <input class="form-control form-control-sm"
                       value="@Items[key]"
                       @onchange="@(e => UpdateValue(key, e.Value))" />
                }
                else
                {
                    var nested = Items[key];
                    if (nested is IConfigFile value)
                    {
                        @((RenderFragment)value.Dispatcher(value, new ValueEditorFragmentDispatcher()))
                    }
                }
            </div>
            <div class="col-auto">
                <button class="btn btn-outline-danger btn-sm" @onclick="@(() => Items.Remove(key))">Remove</button>
            </div>
        </div>
    }
    @* You'd need two temporary fields here to add a New Key and New Value *@
    <button type="button" class="btn btn-primary btn-sm" @onclick="AddItem">+ Add Item</button>
</div>

<style>
    .mb-dictionary-editor
    {
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: 1fr;
    }

    .mb-dictionary-item
    {
        display: grid;
        border: 1px solid green;
        padding: .75rem;
    }

    .mb-dictionary-key
    {
        display: flex;
        &::before {
            content: "Key: ";
            align-content: center;
        }
    }
</style>

@code {
        [Parameter] public IDictionary<TKey, TValue> Items { get; set; } = new Dictionary<TKey, TValue>();
        [Parameter] public PropertyMetadata propertyInfo { get; set; } = default!;
        [Parameter] public IConfigFile? SettingsObject { get; set; }
        [CascadingParameter] public EditContext? CurrentContext { get; set; } = default!;
        [CascadingParameter] public ValidationMessageStore? MessageStore { get; set; } = default!;

    private void UpdateValue(TKey key, object? val)
    {
        Items[key] = (TValue)Convert.ChangeType(val, typeof(TValue))!;
    }

    private void UpdateKey(TKey key, object value)
    {
        TKey newKeyValue = (TKey)value;
        var dictValue = Items[key];
        Items.Remove(key);
        Items.Add(newKeyValue, dictValue);
    }

    private void AddItem()
    {
        MessageStore?.Clear(new FieldIdentifier(SettingsObject!, propertyInfo.Name));
        var keyValue = (TKey)propertyInfo.NewTypePropertyOne();
        if (!typeof(TKey).IsPrimitive && typeof(TKey) != typeof(string) || keyValue == null)
        {
            // we can't handle this, it will in the future throw an error in the Core package
            return;
        }
        if (!typeof(TValue).IsPrimitive && typeof(TValue) != typeof(string))
        {
            var value = (TValue)propertyInfo.NewTypePropertyTwo();
            var test = new KeyValuePair<TKey, TValue>(keyValue, value);
            if (!Items.ContainsKey(keyValue))
            {
                Items.Add(test);
            }
            else
            {
                MessageStore?.Add(new FieldIdentifier(SettingsObject!, propertyInfo.Name), "Attempting to add Key that aleady exists, Please edit other default key first.");
            }
        }
        
        CurrentContext?.NotifyValidationStateChanged();
    }   
}
