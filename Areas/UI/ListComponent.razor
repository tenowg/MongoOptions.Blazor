@typeparam TItem
@using System.Reflection
@using Microsoft.AspNetCore.Components.Forms

<div class="list-editor border p-3 mb-3">
    <h6>@Label</h6>
    @foreach (var (item, index) in Items.Select((value, i) => (value, i)))
    {
        <div class="d-flex mb-2">
            <span class="me-2 mt-1">@index:</span>

            @if (typeof(TItem).IsPrimitive || typeof(TItem) == typeof(string))
            {
            <input class="form-control"
                   value="@item"
                   @onchange="@(e => UpdateItem(index, e.Value))" />
            } else
            {
                dynamic nested = item;
                <ValueEditor SettingsObject="nested"/>
            }
            <button type="button" class="btn btn-danger btn-sm ms-2"
                    @onclick="@(() => RemoveItem(index))">
                ✕
            </button>
        </div>
    }
    <button type="button" class="btn btn-primary btn-sm" @onclick="AddItem">+ Add Item</button>
</div>

@code {
    [Parameter] public IList<TItem> Items { get; set; } = new List<TItem>();
    [Parameter] public string Label { get; set; } = "";
    [CascadingParameter] public EditContext CurrentContext { get; set; } = default!;

    private void UpdateItem(int index, object? value)
    {
        Items[index] = (TItem)FlexibleConvert(value, typeof(TItem))!;
        CurrentContext.NotifyFieldChanged(new FieldIdentifier(Items, ""));
    }

    private void AddItem()
    {
        if (!typeof(TItem).IsPrimitive && typeof(TItem) != typeof(string))
        {
            var test = Activator.CreateInstance<TItem>();
            Items.Add(test);
        }
        else
        {
            Items.Add(default!); // Or handle constructor for complex types
            CurrentContext.NotifyValidationStateChanged();
        }
    }

    private void RemoveItem(int index)
    {
        
        Items.RemoveAt(index);
        CurrentContext.NotifyValidationStateChanged();
    }

    /// <summary>
    /// Converts an object to the specified target type with support for Guids and enums.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <param name="targetType">The target type to convert to.</param>
    /// <returns>The converted object.</returns>
    public object? FlexibleConvert(object? value, Type targetType)
    {
        if (value == null || value.ToString() == "") return null;

        // 1. Handle Guids
        if (targetType == typeof(Guid))
            return Guid.Parse(value.ToString()!);

        // 2. Handle Enums
        if (targetType.IsEnum)
            return Enum.Parse(targetType, value.ToString()!);

        // 3. Fallback to standard conversion
        return Convert.ChangeType(value, targetType);
    }
}