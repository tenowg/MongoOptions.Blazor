@typeparam TItem
@using System.Reflection
@using Microsoft.AspNetCore.Components.Forms

<div class="mb-list-editor p-3 mb-3">
    @* <h6>@Label</h6> *@
    @foreach (var (item, index) in Items.Select((value, i) => (value, i)))
    {   
        <div class="mb-list-item">
            <div class="me-2 mt-1 mb-list-index">@index:</div>
            <div class="">   
                @if (typeof(TItem).IsPrimitive || typeof(TItem) == typeof(string))
                {
                <input class="form-control"
                       value="@item"
                       @onchange="@(e => UpdateItem(index, e.Value))" />
                } else
                {
                    dynamic nested = item;
                    <ValueEditor SettingsObject="nested"/>
                }
            </div>
            <button type="button" class="btn btn-danger btn-sm ms-2 mb-item-button"
                        @onclick="@(() => RemoveItem(index))">
                    ✕
            </button>
        </div>
    }
    <button type="button" class="mb-list-add btn btn-primary btn-sm" @onclick="AddItem">+ Add Item</button>
</div>

<style>
    .mb-list-editor
    {
        display: flex;
        flex-direction: column;
    }

    .mb-list-item
    {
        display: grid;
        grid-template-columns: auto 1fr auto;
        padding: 5px 0px 5px 0px;
    }
    
    .mb-list-index
    {
        align-content: center;
    }

    .mb-item-button {
        margin: 5px 0;
    }
</style>

@code {
    [Parameter] public IList<TItem> Items { get; set; } = new List<TItem>();
    [Parameter] public string Label { get; set; } = "";
    [CascadingParameter] public EditContext CurrentContext { get; set; } = default!;

    private void UpdateItem(int index, object? value)
    {
        Items[index] = (TItem)FlexibleConvert(value, typeof(TItem))!;
        CurrentContext.NotifyFieldChanged(new FieldIdentifier(Items, ""));
    }

    private void AddItem()
    {
        if (!typeof(TItem).IsPrimitive && typeof(TItem) != typeof(string))
        {
            var test = Activator.CreateInstance<TItem>();
            Items.Add(test);
        }
        else
        {
            Items.Add(default!); // Or handle constructor for complex types
            CurrentContext.NotifyValidationStateChanged();
        }
    }

    private void RemoveItem(int index)
    {
        
        Items.RemoveAt(index);
        CurrentContext.NotifyValidationStateChanged();
    }

    /// <summary>
    /// Converts an object to the specified target type with support for Guids and enums.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <param name="targetType">The target type to convert to.</param>
    /// <returns>The converted object.</returns>
    public object? FlexibleConvert(object? value, Type targetType)
    {
        if (value == null || value.ToString() == "") return null;

        // 1. Handle Guids
        if (targetType == typeof(Guid))
            return Guid.Parse(value.ToString()!);

        // 2. Handle Enums
        if (targetType.IsEnum)
            return Enum.Parse(targetType, value.ToString()!);

        // 3. Fallback to standard conversion
        return Convert.ChangeType(value, targetType);
    }
}