@typeparam T where T : class, IConfigFile
@using System.ComponentModel.DataAnnotations
@using System.Linq.Expressions
@using System.Reflection
@using MongoOptions.Interfaces
@using Microsoft.AspNetCore.Components.Forms
@using MongoOptions.Blazor.Areas.UI
@using MongoOptions.Blazor.Components.Fragments
@using MongoOptions.Blazor.Extensions
@using MongoOptions.Blazor.Fragments
@using MongoOptions.Extensions
@using MongoOptions.Types
@using MongoOptions.Services
@inject MongoConfigRegistry registry

@if(SettingsObject != null) {
    @foreach (var prop in SettingsObject.GetProperties())
    {
    var propType = prop.PropertyType;
    <div class="card mb-3 mb-item">
        <label class="form-label mb-display-name">@prop.Name</label><span class="mb-ui-name">@propType.GetUITypeName()</span>
        <div>@prop.Description</div>

            @if (propType.GetUnderlyingType() == typeof(string))
            {
                var expression = (Expression<Func<string>>)prop.ExpressionFactory(SettingsObject);

                <InputText Value="@(prop.Getter(SettingsObject)?.ToString() ?? "failed")"
                    ValueChanged="@(val => prop.Setter(SettingsObject, val))"
                    ValueExpression="@expression"
                    class="form-control" />
            }

            else if (propType.GetUnderlyingType() == typeof(Guid))
            {
                <input type="text"
                    class="form-control"
                    value="@prop.Getter(SettingsObject)"
                    @onchange="@(async e => { await UpdateGuid(e.Value?.ToString() ?? "", prop); })"
                />

            }
            else if (propType.IsSupportedNumber())
            {
                @((RenderFragment)prop.AotDispatch(SettingsObject, new NumberFragmentDispatcher(), prop));
            }
            else if (propType.GetUnderlyingType() == typeof(bool))
            {
                var expression = (Expression<Func<bool>>)prop.ExpressionFactory(SettingsObject);
                <div class="form-check form-switch">
                    <InputCheckbox Value="@((bool)prop.Getter(SettingsObject)!)"
                        ValueChanged="@(val => prop.Setter(SettingsObject, val))"
                        ValueExpression="@expression"
                        class="form-check-input" />
                </div>
            }
            else if (propType.IsEnum)
            {
                @((RenderFragment)prop.AotDispatch(SettingsObject, new EnumFragmentDispatcher(), prop));
            }
            else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IList<>)))
            {
                @((RenderFragment)prop.AotDispatch(SettingsObject, new ListFragmentDispatcher(), prop));
            }
            else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IDictionary<,>)))
            {
                @((RenderFragment)prop.AotDispatch(SettingsObject, new DictionaryEditorFragmentDispatcher(), prop))
            }
            else if (propType.IsClass && !IsAssignableToGenericType(propType, propType))
            {
                var nestedValue = prop.Getter(SettingsObject!)!;
                if (nestedValue == null)
                {
                    nestedValue = prop.New();
                    prop.Setter(SettingsObject, nestedValue);
                }
                var nested = prop.Getter(SettingsObject);
                if (nested is IConfigFile value)
                {
                    @((RenderFragment)value.Dispatcher(value, new ValueEditorFragmentDispatcher()))
                }
            }
        </div>
    }
}
@code {
    [Parameter]public T? SettingsObject { get; set; }
    [CascadingParameter] public EditContext CurrentContext { get; set; } = default!;
    [CascadingParameter] public ValidationMessageStore? MessageStore { get; set; } = default!;

    private async Task UpdateGuid(string val, PropertyMetadata prop)
    {
        var fieldIdentifier = new FieldIdentifier(SettingsObject, prop.Name);
        if (!Guid.TryParse(val, out var result))
        {
            MessageStore?.Add(fieldIdentifier, "That is not a valid GUID format!");
            CurrentContext?.NotifyValidationStateChanged();
        }
        else
        {
            prop.Setter(SettingsObject, result);
            MessageStore?.Clear(new FieldIdentifier(SettingsObject, prop.Name));
            CurrentContext?.NotifyValidationStateChanged();
        }
    }

    /// <summary>
    /// Determines if a type is assignable to a generic type.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <param name="genericInterface">The generic interface to check against.</param>
    /// <returns>True if the type is assignable to the generic type.</returns>
    public static bool IsAssignableToGenericType(Type type, Type genericInterface)
    {
        if (type.IsGenericType && type.GetGenericTypeDefinition() == genericInterface)
            return true;

        return type.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == genericInterface);
    }
}
