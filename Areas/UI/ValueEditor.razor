@typeparam T where T : class, new()
@using System.Reflection
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Components.Forms
@using System.Linq.Expressions
@using MongoOptions.Blazor.Components.Fragments
@using MongoOptions.Blazor.Extensions
@using MongoOptions.Blazor.Fragments
@using MongoOptions.Extensions
@using MongoOptions.Blazor.Areas.UI

@foreach (var prop in typeof(T).GetEligibleProperties())
{
    var propType = prop.PropertyType;
    <div class="mb-3 ms-3">
        <label class="form-label">@prop.GetDisplayName()</label><span>@propType.GetUITypeName()</span>

        @if (propType.GetUnderlyingType() == typeof(string))
        {
            var expression = prop.CreateLambda<string>(SettingsObject);
            <InputText Value="@(prop.GetValue(SettingsObject) as string ?? string.Empty)"
                       ValueChanged="@(val => prop.SetValue(SettingsObject, val))"
                       ValueExpression="@expression"
                       class="form-control" />
        }
        
        else if (propType.GetUnderlyingType() == typeof(Guid))
        {
            var expression = prop.CreateLambda<Guid>(SettingsObject);

            <input type="text"
                   class="form-control"
                   value="@prop.GetValue(SettingsObject)"
                   @onchange="@(async e => { await UpdateGuid(e.Value?.ToString() ?? "", prop); })"
                   />
            <ValidationMessage For="@expression" />
            
        }
        else if (propType.IsSupportedNumber())
        {
            @NumberFragments.GetDynamicFragment(SettingsObject, prop);
        }
        else if (propType.GetUnderlyingType() == typeof(bool))
        {
            var expression = prop.CreateLambda<bool>(SettingsObject);
            <div class="form-check form-switch">
                <InputCheckbox Value="@((bool)prop.GetValue(SettingsObject)!)"
                               ValueChanged="@(val => prop.SetValue(SettingsObject, val))"
                               ValueExpression="@expression"
                               class="form-check-input" />
            </div>
        }
        else if (propType.IsEnum)
        {
            @EnumFragments.GetDynamicFragment(SettingsObject, prop);
        }
        else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IList<>)))
        {
            var itemType = propType.GetGenericArguments()[0];
            var listInstance = prop.GetValue(SettingsObject);
            var instance = typeof(ListComponent<>).MakeGenericType(itemType);
            <DynamicComponent Type="@instance" Parameters="@(new Dictionary<string, object> { 
                          ["Items"] = listInstance!, 
                          ["Label"] = prop.Name 
                      })" />
        }
        else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IDictionary<,>)))
        {
            var expression = prop.CreateLambda(SettingsObject, propType);
            var itemType = propType.GetGenericArguments()[1];
            var keyType = propType.GetGenericArguments()[0];
            var listInstance = prop.GetValue(SettingsObject);
            var instance = typeof(DictionaryEditor<,,>).MakeGenericType(keyType, itemType, typeof(T));
            <CascadingValue Value="@SettingsObject">
            <DynamicComponent Type="@instance" Parameters="@(new Dictionary<string, object> { 
                          ["Items"] = listInstance!, 
                          ["Label"] = prop.Name,
                          ["propertyInfo"] = prop
                      })" />
            </CascadingValue>
            <ValidationMessage For="@expression" />
        }
        else if (propType.IsClass && !IsAssignableToGenericType(propType, propType))
        {
            dynamic nestedValue = prop.GetValue(SettingsObject!)!;
            if (nestedValue == null)
            {
                nestedValue = Activator.CreateInstance(propType)!;
                prop.SetValue(SettingsObject, nestedValue);
            }

            <ValueEditor SettingsObject="nestedValue"/>
        }
    </div>
}

@code {
    [Parameter] public T SettingsObject { get; set; } = new();
    [CascadingParameter] public EditContext CurrentContext { get; set; } = default!;
    [CascadingParameter] public ValidationMessageStore? MessageStore { get; set; } = default!;

    private async Task UpdateGuid(string val, PropertyInfo prop)
    {
        var fieldIdentifier = new FieldIdentifier(SettingsObject, prop.Name);
        if (!Guid.TryParse(val, out var result))
        {
            MessageStore?.Add(fieldIdentifier, "That is not a valid GUID format!");
            CurrentContext?.NotifyValidationStateChanged();
        }
        else
        {
            prop.SetValue(SettingsObject, result);
            MessageStore?.Clear(new FieldIdentifier(SettingsObject, prop.Name));
            CurrentContext?.NotifyValidationStateChanged();
        }
    }

    /// <summary>
    /// Determines if a type is assignable to a generic type.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <param name="genericInterface">The generic interface to check against.</param>
    /// <returns>True if the type is assignable to the generic type.</returns>
    public static bool IsAssignableToGenericType(Type type, Type genericInterface)
    {
        if (type.IsGenericType && type.GetGenericTypeDefinition() == genericInterface)
            return true;

        return type.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == genericInterface);
    }
}
