@typeparam T where T : class, IConfigFile
@using System.ComponentModel.DataAnnotations
@using System.Linq.Expressions
@using System.Reflection
@using MongoOptions.Interfaces
@using Microsoft.AspNetCore.Components.Forms
@using MongoOptions.Blazor.Areas.UI
@using MongoOptions.Blazor.Components.Fragments
@using MongoOptions.Blazor.Extensions
@using MongoOptions.Blazor.Fragments
@using MongoOptions.Extensions

@if(SettingsObject != null) {
    @foreach (var prop in SettingsObject.GetProperties())
    {
    var propType = prop.PropertyType;
    <div class="card mb-3 mb-item">
        <label class="form-label mb-display-name">@prop.Name</label><span class="mb-ui-name">@propType.GetUITypeName()</span>
        <div>@prop.Description</div>

        @if (propType.GetUnderlyingType() == typeof(string))
        {
            var expression = (Expression<Func<string>>)prop.ExpressionFactory(SettingsObject);

            <InputText Value="@(prop.Getter(SettingsObject)?.ToString() ?? "failed")"
                       ValueChanged="@(val => prop.Setter(SettingsObject, val))"
                       ValueExpression="@expression"
                       class="form-control" />
        }
        
        else if (propType.GetUnderlyingType() == typeof(Guid))
        {
            <input type="text"
                   class="form-control"
                   value="@prop.Getter(SettingsObject)"
                   @onchange="@(async e => { await UpdateGuid(e.Value?.ToString() ?? "", prop); })"
                   />
            
        }
        else if (propType.IsSupportedNumber())
        {
            @((RenderFragment)prop.Dispatcher(SettingsObject, new NumberFragmentDispatcher(), prop))
        }
        else if (propType.GetUnderlyingType() == typeof(bool))
        {
            var expression = (Expression<Func<bool>>)prop.ExpressionFactory(SettingsObject);
            <div class="form-check form-switch">
                <InputCheckbox Value="@((bool)prop.Getter(SettingsObject)!)"
                               ValueChanged="@(val => prop.Setter(SettingsObject, val))"
                               ValueExpression="@expression"
                               class="form-check-input" />
            </div>
        }
        else if (propType.IsEnum)
        {
            @((RenderFragment)prop.Dispatcher(SettingsObject, new EnumFragmentDispatcher(), prop));
        }
        else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IList<>)))
        {
            var itemType = propType.GetGenericArguments()[0];
            var listInstance = prop.Getter(SettingsObject);
            var instance = typeof(ListComponent<>).MakeGenericType(itemType);
            <DynamicComponent Type="@instance" Parameters="@(new Dictionary<string, object> { 
                          ["Items"] = listInstance!, 
                          ["Label"] = prop.Name 
                      })" />
        }
         else if (IsAssignableToGenericType(propType.GetUnderlyingType(), typeof(IDictionary<,>)))
        {
            //var expression = prop.CreateLambda(SettingsObject, propType);
            //var expression = (Expression<Func<Dictionary<object,object>>>)prop.ExpressionFactory(SettingsObject);
            var itemType = propType.GetGenericArguments()[1];
            var keyType = propType.GetGenericArguments()[0];
            var listInstance = prop.Getter(SettingsObject);
            var instance = typeof(DictionaryEditor<,,>).MakeGenericType(keyType, itemType, typeof(T));
            <CascadingValue Value="@SettingsObject">
            <DynamicComponent Type="@instance" Parameters="@(new Dictionary<string, object> { 
                          ["Items"] = listInstance!, 
                          ["Label"] = prop.Name,
                          ["propertyInfo"] = prop
                      })" />
            </CascadingValue>
            //<ValidationMessage For="@expression" />
        } 
        else if (propType.IsClass && !IsAssignableToGenericType(propType, propType))
        {
            dynamic nestedValue = prop.Getter(SettingsObject!)!;
            if (nestedValue == null)
            {
                nestedValue = Activator.CreateInstance(propType)!;
                prop.Setter(SettingsObject, nestedValue);
            }

            @* <ValueEditor SettingsObject="nestedValue"/> *@
        }
    </div>
    }
}
@code {
    [Parameter]public T? SettingsObject { get; set; }
    [CascadingParameter] public EditContext CurrentContext { get; set; } = default!;
    [CascadingParameter] public ValidationMessageStore? MessageStore { get; set; } = default!;

    private async Task UpdateGuid(string val, PropertyMetadata prop)
    {
        var fieldIdentifier = new FieldIdentifier(SettingsObject, prop.Name);
        if (!Guid.TryParse(val, out var result))
        {
            MessageStore?.Add(fieldIdentifier, "That is not a valid GUID format!");
            CurrentContext?.NotifyValidationStateChanged();
        }
        else
        {
            prop.Setter(SettingsObject, result);
            MessageStore?.Clear(new FieldIdentifier(SettingsObject, prop.Name));
            CurrentContext?.NotifyValidationStateChanged();
        }
    }

    /// <summary>
    /// Determines if a type is assignable to a generic type.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <param name="genericInterface">The generic interface to check against.</param>
    /// <returns>True if the type is assignable to the generic type.</returns>
    public static bool IsAssignableToGenericType(Type type, Type genericInterface)
    {
        if (type.IsGenericType && type.GetGenericTypeDefinition() == genericInterface)
            return true;

        return type.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == genericInterface);
    }
}
